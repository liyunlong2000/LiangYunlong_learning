# lecture2
## 位级操作
### 布尔代数
- 按位与运算符：&
- 按位或运算符：|
- 异或运算符：^
- 取反运算符：~
### 表示&操作集合
- 表示集合：w位比特能够表示集合{0,...,w-1},从右往左开始比特序号为0,...,w-1,对应序号i的比特为1表示元素i在集合中，为0表示元素i不在集合中。
- 操作集合：
  1. 按位与&：交集 
  2. 按位或|：并集 
  3. 异或^：对称差集 
  4. 取反~：补集
### 移位操作
- 左移：x<<y
  - 低位补0
- 右移：x>>y
  - 逻辑移位：对于无符号数而言，高位补0
  - 算术移位：对于有符号数而言，高位补1
- 当位移数小于0或大于等于字长时，是未经定义的
## 整数
### 符号数和无符号数
- 无符号数：对于w位比特序列，从低位到高位的权重为1,2,...,2^(w-1)
- 符号数：对于w位比特序列，从低位到高位的权重为1,2,...,-2^(w-1)
  - 最高位表示符号，1为负，0为正
  - 这种表示方法也就是补码，更好理解
  - 位扩展：扩展的高位填充原补码的符号位
### 转换
  ![image](https://user-images.githubusercontent.com/56336922/188169460-fec01c39-8c08-4e6c-b618-d4c4baf4be21.png)
### C中符号数和无符号数
- 隐式类型转换：若一个表达式中混合了符号数和无符号数，则会将符号数转为无符号数比较。
### 扩展&截断
  - 位扩展：对于符号数，扩展的高位填充原补码的符号位。对于无符号数，扩展位填0.
    - 当从小的数据类型转成大的数据类型时，c会自动进行位扩展转换
  - 截断：直接截去高位的比特，对于无符号数，类似于mod操作。
## 内存中的表示、指针、字符串
### 机器字
  - 字长：指的是CPU一次能并行处理的二进制位数
    - 也用来表示虚拟地址的空间
### 面向字的内存组织
  - 可以想象内存为一个很大的字节数组
  - 内存中机器字的地址用第一个字节的地址表示
  ![image](https://user-images.githubusercontent.com/56336922/188178958-f04f09a0-fc08-45de-a772-2dc178c69d53.png)
### 字节顺序
  - 大端序：高位字节存在低位地址(Internet传输)
  - 小端序：高位字节存在高位地址(运行在安卓、苹果和windos上的x86 ARM处理器)
  ![image](https://user-images.githubusercontent.com/56336922/188179439-66a9f835-a04b-4d1a-b33b-8e0b57fbe342.png)
  上图为不同端序之间的例子
  ![image](https://user-images.githubusercontent.com/56336922/188179653-364a2272-1278-42bb-8d72-977813ed07a5.png)
  上图为不同端序之间的转换的例子
### 练习题(C Puzzles)
  ![image](https://user-images.githubusercontent.com/56336922/188181250-f9e912af-4bd5-415e-a7b0-fbe46548259b.png)
  1. false：负溢
  2. true：
  3. true:低位位1，左移30位保留后为负
  4. false：无符号数和符号数混合时，将符号数转为无符号数，-1->Umax
  5. false：y为Tmin
  6. false：正溢
  7. false：正溢
  8. true：正数比负数少一位，有相应的负数
  9. false：Tmin
  10. false：x=0，仍为0
  


  
