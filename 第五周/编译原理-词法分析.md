# 词法分析
## 主要任务
词法分析（lexical analysis）：将字符序列转换为单词（Token）序列的过程。进行词法分析的程序或者函数叫作词法分析器（Lexical analyzer，简称Lexer），也叫扫描器（Scanner）。
## 词法记号及属性
### 词法记号、词法单元、模式
- 词法记号(token)：由记号名和属性值二元组，属性值不是必修的
- 记号名：表示记号的种类，如关键字，标识符等
- 模式(pattern)：描述token的构词规则
- 词法单元(lexeme)：匹配模式的实例
- 属性：标记了该词法单元是记号名中模式的具体实例。例如，对于记号名relop，有`<=`,'<'等词法单元实例，属性值指出是哪一个实例

### 注意事项
关键字不等同于保留字，C语言中的关键字是保留字。对于一些语言，关键字可能不是保留字。
- 关键字：有专门的意义和用途，如if 、else
- 保留字：有专门的意义, 不能当作一般的标识符使用

## 词法记号的描述
### 串和语言
#### 术语
- 字母表：有限符号集，例如 $\sum$={0,1}
- 串：符号集上有限序列，例如 0110, $\varepsilon$
- 语言：符号集上的串集，例如 {$\varepsilon$}，{0,00,000,,...}
- 句子：串集中任一元素

#### 串的运算
即元素级的运算：
- 连接：序列的顺序连接，构成新的有限序列
- 幂：序列自身多次连接

#### 语言运算
即集合之间的运算：
- 并：集合并
- 连接：笛卡尔积
- 幂：集合自身多次笛卡尔积
- 闭包： $L^*$ = $L^0$ $\bigcup$ $L^1$ $\bigcup$ $L^2$ $\bigcup$ ...
- 正闭包：$L^+$ = $L^1$ $\bigcup$ $L^2$ $\bigcup$ $L^3$ $\bigcup$ ...

### 正规表达式
正规表达式能够用来表示简单的语言，表示的集合称为正规集，即可以形式化地描述token的模式。
![image](https://user-images.githubusercontent.com/56336922/190978890-abab39c6-553b-49b7-bf07-f1577f68b69e.png)

- $\varepsilon$：空串集
- a：由串'a'构成的集合
- (r)：匹配正则表达式r的串集
- (r)|(s)：正则表达式r表示的串集和s表示的串集的并集
- (r)(s)：正则表达式r表示的串集和s表示的串集的笛卡尔积
- $(r)^* $ ：正则表达式r表示的串集的闭包

即正则表达式之间组合，对应于正则表达式表示串集之间的运算。

#### 语法糖
可以引入语法糖简化正则表达式，例如：
- [a-zA-Z]：使用[]表示元素之间的任意元素
- $digit^* $ :使用星号* 表示0个或多个，即闭包运算
- $digit^+ $ :使用加号+ 表示1个或多个，即正闭包运算
- $digit^? $ :使用问号? 表示0个或1个
### 正规定义
- 对正则表达式命名，这样可以简洁、方便地使用正则表达式
  - 例如C语言中的数字，可以使用`digit`来命名对应的正则表达式，`digit-> 0|1|...|9`
- 正规表达式中可以使用已定义的正规定义
  - 将正规定义看做正则表达式
 
## 词法记号的识别
### 状态转换图
![image](https://user-images.githubusercontent.com/56336922/190983452-a1fede28-b995-45c7-83ed-7ffd4e54a615.png)

上图展示了用于识别关系运算符的转换图。从开始状态开始，根据读入的字符进行状态跳转，若到达接收状态，则成功识别出token。

### 有限自动机
![image](https://user-images.githubusercontent.com/56336922/190986576-25aca9a3-05e9-4547-a43a-ca0059c2c4cc.png)

NFA与DFA的区别在于转换函数的不同：
- DFA：只能转换到具体的状态
- NFA：能够转换到多种状态，具有不确定性
## 词法分析器构造过程
词法分析器的自动生成过程为:
- 使用正则表达式RE描述token规范
- 将正则表达式RE转换成不确定的有限自动机NFA
  - Thopson算法
- NFA转换为有限自动机DFA
  - 子集构造算法
- DFA的最小化
  - Hopcroft算法
- 由DFA生成分析算法
### RE转换为NFA
Thopson算法思想：对RE的结构做归纳
  - 对基本RE直接构造
  - 对复合RE递归构造

![image](https://user-images.githubusercontent.com/56336922/190990387-53132717-6992-4540-8e01-3d4c6f8e4c33.png)

自顶向下地完成构造：
- 先从上层对应到合适的结构
- 再不断细化子表达式，直到构造完基本RE

### NFA转换为DFA
子集构造算法思想：
- DFA的开始状态为NFA中开始状态集合的$\varepsilon$ -闭包
- 对于DFA中每个状态，遍历符号集，对于读入符号a
  - 根据NFA，找到该状态所能到达的NFA状态集合的$\varepsilon$ -闭包，其成为DFA中一个状态


算法终止?
- DFA状态集中元素为NFA中状态的集合，最多有2^N个，N为NFA中状态个数。而每次循环，DFA状态集最多增加一个元素，增加总个数有上限。
### DFA的最小化
Hopcroft算法思想：基于等价类思想
1. 根据是否为接收状态划分状态集
2. 遍历划分后的集合，对其进行等价类划分
  - 对于集合中每个元素，遍历符号集，对于读入符号a，判断各元素是否转移到同一元素
    - 若相同，则符号a不能划分集合
    - 若不同，则符号a能够划分集合，转移后元素对应的原像集即为该集合的一个划分
3. 循环第2步，直到各集合不能划分为止







